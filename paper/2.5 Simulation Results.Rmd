Section 2.5 discusses using the Markov Transition Matrices created to generate a simulation on all open claims in the modeled data. The end result of this simulation gives us the when and how (with our without value) each open claim is simulated to close.

To start we need to create our database of open claims. The code below is specifically related to the data we are using, there will be differences in the code depnding on the data that is being modeled. The important fields to generate are "mtm_code", "z_nz", and "mtm_code_with_mat" as these fields will be passed through the functions of the `R` package.

```{r echo=TRUE, eval=FALSE}
open_claims <- synthetic_data %>%
  dplyr::select(- c(LoB, cc, AY, AQ, age, inj_part, RepDel)) #remove fields not used
  
open_claims <- open_claims %>%
  dplyr::mutate(maturity = rowSums(open_claims[14:25])) %>% #find maturity at last open interval
  dplyr::mutate(paid = rowSums(open_claims[2:maturity+1])) %>% #find value at last open interval
  dplyr::select(ClNr, maturity, paid) %>%
  dplyr::filter(maturity > 0) %>% #filter out closed claims at time 0
  dplyr::mutate(mtm_code = case_when(
    paid == 0 ~ "oz",
    paid > 0 ~ "onz"
  )) %>% #assign mtm_code
  dplyr::mutate(z_nz = ifelse(
      paid > 0, "nz", "z")) %>% #assign whether zero or non-zero
  dplyr::mutate(
    mtm_code_with_mat = paste(mtm_code, maturity, sep = '_'))

```

Now that we have our open claims database we can run it through our simulation model. The first step is to convert the matrices to have a class that functions with the markovchain package.

```{r echo=TRUE, eval=FALSE}
#convert the selection matrices to class = Markov Chain
mtm_selections <- lapply(mtm_selections, function(x){
  as(object = x, Class = "markovchain")
})

```

Next, we use the function "open_sim" from the accompanying `R` package. In order to produce the same result every time the simulation is run we need to set an initial seed. We then choose the number of iterations we want to simulate - for our case study we chose to run 1,000 iterations. There are two inputs to the "open_sim" function, the first is the identifier for each claim in the database of open claims, in this case study that is the "ClNr" field of our "open_claims" database. The next input for the function is the last maturity of the transition matrix which in this case study is 11. 

```{r echo=TRUE, eval=FALSE}

set.seed(14159) #for reproducibility
my_iters = 1000
last_mat = 11 #last maturity
results<- lapply(open_claims$ClNr, last_mat, FUN = open_sim)

names(results) <- paste0('claim_', open_claims$ClNr)

rm(mtm_selections)

```

After running the simulation we produce a list of each open claim and the 1,000 iterations of the closing states. The following code allows you to view the individual claims and their simulated output. 

##AT - figure out way to show the below code

```{r echo=TRUE, eval=FALSE}

Map(head,results[43],5)

```
We are looking at the first 5 simulations for claim number 79 which is the 43rd element in the list we created. If we look at the first iteration, we can see the claim stayed open zero at lag 1 and closed zero at lag 2. For the second iteration the claim stayed open until lag 11 switching from open zero to open non-zero at lag 2. Having the ability to view the simulation this closely allows you to drill down into each individual claim which is a resourceful tool when explaining results.

In the next Section we will discuss aplying a severity model to the open claims.